(function() {
  var IS_NODE, buildArray, buildDict, intermine, __root__,
    __slice = [].slice;

  IS_NODE = typeof exports !== 'undefined';

  __root__ = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (IS_NODE) {
    intermine = __root__;
  } else {
    intermine = __root__.intermine;
    if (intermine == null) {
      intermine = __root__.intermine = {};
    }
  }

  if (intermine.compression == null) {
    intermine.compression = {};
  }

  buildDict = function(size) {
    var dict, i, _i;
    dict = {};
    for (i = _i = 0; 0 <= size ? _i <= size : _i >= size; i = 0 <= size ? ++_i : --_i) {
      dict[String.fromCharCode(i)] = i;
    }
    return dict;
  };

  buildArray = function(size) {
    var x, _i, _results;
    _results = [];
    for (x = _i = 0; 0 <= size ? _i <= size : _i >= size; x = 0 <= size ? ++_i : --_i) {
      _results.push(String.fromCharCode(x));
    }
    return _results;
  };

  intermine.compression.LZW = {
    encode: function(s) {
      var char, currPhrase, data, dict, dictSize, out, phrase, _i, _len;
      data = (s + "").split("");
      out = [];
      phrase = '';
      dictSize = 256;
      dict = buildDict(dictSize);
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        char = data[_i];
        currPhrase = phrase + char;
        if (currPhrase in dict) {
          phrase = currPhrase;
        } else {
          out.push(dict[phrase]);
          dict[currPhrase] = dictSize++;
          phrase = String(char);
        }
      }
      if (phrase !== '') {
        out.push(dict[phrase]);
      }
      return out;
    },
    decode: function(data) {
      var code, dict, dictSize, entry, head, result, tail, word, _i, _len;
      dictSize = 256;
      dict = buildArray(dictSize);
      entry = '';
      head = data[0], tail = 2 <= data.length ? __slice.call(data, 1) : [];
      word = String.fromCharCode(head);
      result = [word];
      for (_i = 0, _len = tail.length; _i < _len; _i++) {
        code = tail[_i];
        entry = (function() {
          if (dict[code]) {
            return dict[code];
          } else if (code === dictSize) {
            return word + word.charAt(0);
          } else {
            throw new Error("Key is " + code);
          }
        })();
        result.push(entry);
        dict[dictSize++] = word + entry.charAt(0);
        word = entry;
      }
      return result.join('');
    }
  };

}).call(this);
